1. Java의 특징 설명해주세요.
  Java는 객체지향 프로그래밍 언어,
  객체지향 특징인 추상화, 캡슐화, 상속, 다형성이 잘 적용된 언어입니다.
  장점 : JVM 에서 동작하기에 운영체제에 독립적
        GabageCollector를 통한 자동적인 메모리 관리 가능
  단점 : 다중 상속이나 타입에 엄격하며, 제약이 많음
  
2. JVM의 역할에 대해 설명해주세요.
  JVM은 스택 기반으로 동작하고 OS에 맞게 해석해주고, 가비지컬렉션을 통해 자동적인 메모리 관리해줍니다.
  
  
3. Java의 컴파일 과정에 대해 설명
  개발자 .java 파일 생성
  build하고
  java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.
  Class Loader를 통해 JVM 메모리 내로 로드한다.
  실행엔진을 통해 각 운영체제에 맞는 기계어로 해석해서 Runtime Data Area에 배치
  
4. Complier vs InterPreter 는 무엇인가
  Complier 프로그램을 runtime 전에 전체 소스를 검사하여 machine code 로 변환한다.
  소스코드 분석하는데 시간이 오래 걸리고
  Object Code를 생성하여 더 많은 메모리 필요
  전체 코드 검사한 후 오류 메시지 생성, 실행 전에 오류를 발견 가능
  ex) C,C++, Java
  
  Interpreter
  프로그램 runtime에 한 번에 한 문장씩 변환
  소스 코드를 분석하는데 시간은 적지만 전체 실행 시간은 complier보다 느림
  Object Code가 만들어지지않아 메모리 효율이 높음
  첫 오류를 만날 때 까지 프로그램을 계속 번역하고 오류 만나면 중지
  프로그램 실행 전에 오류를 발견하기 어려움
  ex) Python
  
5. Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트 차지
  정수형 byte 1 , short 2 , int 4 , long 8 
  실수형 float 4 , double 8
  문자형 char 2
  논리형 boolean 1
  
  참조타입
  Java에서 실제 객체는 힙 영역에 저장되며 참조 타입 변수는 스택 영역에 실제 객체들의 주소를 저장하여, 
  객체를 사용할때 마다 참조 변수에 저장된 객체의 주소를 불러와 사용하는 방식이다.
  
  차이점 
  Null을 담을 수 있는가?
  int i = null;//불가능
  Integer integer = null; //가능
  
  제네릭 타입에서 사용할 수 있는가?
  List<int> i;//불가능
  List<Integer> integer;//가능
  
6. 오버라이딩(Overriding), 오버로딩(Overloading)
  오버라이딩 : 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말하고,
  오버로딩 : 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의한다.
  
7. 객체지향 프로그래밍(OOP)에 대해 설명해주세요.
  객체지향 프로그래밍은 객체의 관점에서 프로그래밍하는 것이다.
  추상화, 캡슐화, 상속, 다형성과 같은 특징이 있으며 코드의 재사용성과 중복제거가 가장 큰 목적이다.
  
  추상화 : 공통의 속성이나 기능을 묶어 이름을 붙이는 것
  캡슐화 : 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것
  상속 : 상위 개념의 특징을 하위 개념이 물려받는것
  다형성 : 부모클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것
  
8. 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.
  불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말합니다.
  원시 타입인 경우 final 키워드를 사용해 불변 객체 생성
  참조 타입일 경우엔 추가적인 작업 필요
  
  추가적인 작업은 1. 객체, 2. 배열 3. List가 있는데 
  객체는 필드 참조 변수도 불변 객체로 변경
  배열은 배열을 copy 해서 getter를 clone으로 반환하도록 사용
  리스트인 경우 새로운 List를 만들어서 clone해서 사용
  
9. 불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?
  불변 객체나 final 키워드를 사용해 얻는 이점은 다음과 같습니다.

  1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
  (공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)

  2. 실패 원자적인 메소드를 만들 수 있다.
  (어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)

  3. 부수효과를 피해 오류를 최소화 할 수 있다.
  ※ 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상

  4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.

  5. 가비지 컬렉션 성능을 높일 수 있다.
  (가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)

10. 추상 클래스와 인터페이스 설명하고 차이
  추상 클래스 : 클래스 내 추상 메소드가 하나이상 포함되거나 abstract로 정의된 경우를 말하고
  인터페이스 : 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.
  
  공통점은 사용하기 위해서는 하위클래스에서 확장/구현해야한다., new 연산자로 인스턴스 생성 불가능
  차이점 : 인터페이스는 모든 클래스에 대해 특정한 메소드가 반드시 존재, 다중상속 가능
         추상클래스는 상속받은 클래스들의 공통적인 로직을 추상화시키고, 기능 확장을 위해 사용, 다중상속 불가능
  
11. 싱글톤 패턴에대해 설명해주세요.
  단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다.
  동일한 인스턴스를 자주 생성해야하는 경우에 주로 사용(메모리 낭비 방지)
  
  예시로 Spring Bean이 있습니다.
  빈 등록하고 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다.
  스프링은 요청할때마다 새로운 객체를 생성해서 반환하는 기능도 제공
  @Scope("prototye"), 프로토타입 빈
  
12. 가비지 컬렉션에 대해 설명해주세요.
  JVM 메모리 관리 기법으로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을
  회수하여 메모리를 관리해주는 기법
  
  가비지컬렉션 과정 
  GC 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한
  모든 쓰레드들의 작업을 중단 후 사용하지 않는 메모리를 제거하고 작업이 재개
  GC의 작업은 Young 영역에 대한 Minor Gc와 Old 영역에 대한 Major GC로 구분됩니다.
  
13. 객체지향의 설계원칙에대해 설명해주세요
  SOLID라고하고
  단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
  개방 폐쇄 원칙 : 확장에는 열려있고, 수정에는 닫혀있어야한다
  리스코프 치환 원칙 : 상위 타입은 하위타입으로 대체
  인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한 일수록 좋다.
  의존관계 역전 원칙 : 스프링에 의존성 주입(DI)과 같다
  
14. 자바의 메모리 영역에 대해 설명해주세요.
  Method 영역, Stack 영역, Heap 영역으로 구분, 데이터 타입에 따라 항당됩니다.
  메소드(Method) 영역 : 전역변수, static 변수 저장, 프로그램 시작부터 종료까지 메모리에 남아있다.
  스택(Stack) 영역 : 지역변수와 매개변수 데이터 저장, 메소드 호출 될 때 메모리에 할당 종료되면 해제 
                   LIFO 구조를 가지고 변수에 새로운 데이터가 할당되면 이전 데이터 삭제
  힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스) 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에의해 메모리가 관리
  
  각 메모리 영역이 할당되는 시점은 언제인가요?
    Method : JVM이 동작해서 클래스가 로딩 될때 생성
    Stack : 런타임시 할당
    Heap : 컴파일 타임 시 할당
                
※ 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정 
※ 런타임 : 컴파일 타임 이후 프로그램이 실행되는 때

15. 클래스와 객체, 생성자(인스턴스)에 대해 설명해주세요
  클래스 : 객체를 만들기 위한 설계도
  객체 : 클래스를 기반으로 생성되며 고유의 이름, 상태(fields), 행동(Method)을 갖습니다.
  객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.
  생성자 : 클래스와 같은 이름의 메소드로 객체가 생성될 때 호출되는 메소드, 오버로딩 가능
  
16. Synchronized에 대해 아는 대로 말해주세요.
  여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 
  나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.
  * 데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 
  제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장합니다.
  
  Synchronized는 변수와 메소드에 상용해서 동기화 가능, 남발하게되면 오히려 프로그램 성능 저하
  
  동기와, 비동기, 함수형 인터페이스
  https://velog.io/@pllap/Java%EC%97%90%EC%84%9C%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
  
17. new String() 과 리터럴("")의 차이에 대해 설명해주세요.
  new String()은 new 키워드로 새로운 객체 생성하기에 Heap메모리 영역에 저장
  ""는 Heap 안에 있는 String Constant Pool 영역에 저장
  
18. String, StringBuffer, StringBuilder의 차이를 설명
  String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가집니다.
  StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용
  StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용
 
19. String 객체가 불변인 이유에 대해 아는대로 설명해주세요
  캐싱 기능에 의한 메모리 절약과 속도 향상
    String 객체들은 Heap의 String Pool 이라는 공간에 저장해서 Pool 에 있는 객체를 사용하기 때문에
    특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.
    
  thread-safe
    String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전
    
  보안기능
    중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리
    
20. 접근 제한자(Access Modifier)에 대해 설명해주세요.
  public - 접근 제한 없음
  protected - 패키지 내, 다른 패키지에서 상속받아 자노 클래스에서 접근 가능
  default - 해당 패키지 내에서만 접근 가능
  private - 해당 클래스에서만 접근 가능
  
21. static에 대해 설명해주세요.
  클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용 가능, 즉 인스턴스 생성 없이 바로 사용 가능
  모든 객체가 메모리를 공유한다는 특징이 있고, GC 관리 영역 밖에 있기때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재
  
  사용 이유
  일종의 '전역변수'와 같은 개념을 통해 접근하는게 비용도 줄이고, 효율을 높일 수 있다.
  인스턴스 생성 없이 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용
  
22. Inner Class(내부 클래스)의 장점에 대해 설명해주세요.
  내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
  서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 코드의 캡슐화 증가
  외부에서 내부 클래스에 접근할 수 없으므로 코드의 복잡성 줄일 수 있다.
  
23. Error, Exception 차이
  Error 는 실행 중 일어날 수 있는 치명적 오류, 컴파일 시점에선 체크할 수 없고, 오류가 발생하면 프로그램 비정상 종료
  예측 불가능한 UncheckedException에 속함
  Exception은 Error 보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있다.
  
24. CheckedException, UnCheckedException 차이
  CheckedException은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외처리해야함
  Exception - IOException, ClassNotFoundException
  
  UnCheckedException은 실행하고 난 후에 알 수 있는 예외를 말하고 따로 예외처리를 하지 않아도 됨
  Exception - NullPointerException, ArrayIndexOutOfBoundException

25. 컬렉션 프레임워크에 대해 설명해주세요.
  표준화된 방법을 제공하는 클래스의 집합을 의미
  List, Set, Map, Stack, Queue 등이 존재합니다.
  
26. List, Set, Map
  List는 순서가 있는 데이터의 집합이며, 데이터의 중복을 허용
  Set은 순서가 없는 데이터의 집합, 데이터 중복 허용 안함
  Map은 키와 값이 한 쌍으로 이뤄져 있고, 키를 기준으로 중복을 허용하지 않으며, 순서가 없습니다.


27. 제네릭에 대해 설명해주시고, 왜 쓰는지 알려주세요.
  제네릭은 데이터의 타입을 하나로 지정하지 않고 사용할때마다 범용적이고 포괄적 지정
  제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있습니다.
  
  
 
